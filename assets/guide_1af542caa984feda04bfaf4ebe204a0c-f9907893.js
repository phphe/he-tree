import{_ as u,g as h,u as g,f as p,h as v,r as s,c as f,a as n,b as l,w as d,e,i as c,o as _}from"./index-86792da5.js";import{_ as m,C as x}from"./CodeContainer-bc270f09.js";const D={extends:m,components:{CodeContainer:x},setup(){const a=h(),i={name:"教程",id:"教程",level:1,children:[{name:"安装",id:"安装",level:2,children:[]},{name:"引入",id:"引入",level:2,children:[]},{name:"不要给节点设置外边距",id:"不要给节点设置外边距",level:2,children:[]},{name:"treeData 或 flatData",id:"treedata-或-flatdata",level:2,children:[]},{name:"HTML 结构",id:"html-结构",level:2,children:[]},{name:"使用",id:"使用",level:2,children:[]},{name:"输出数据",id:"输出数据",level:2,children:[]},{name:"折叠和展开",id:"折叠和展开",level:2,children:[]},{name:"按需加载子节点",id:"按需加载子节点",level:2,children:[]},{name:"默认折叠所有节点",id:"默认折叠所有节点",level:2,children:[]},{name:"勾选框",id:"勾选框",level:2,children:[]},{name:"RTL",id:"rtl",level:2,children:[]},{name:"虚拟列表",id:"虚拟列表",level:2,children:[]},{name:"拖拽",id:"拖拽",level:2,children:[]},{name:"拖拽触发",id:"拖拽触发",level:2,children:[]},{name:"阻止拖拽",id:"阻止拖拽",level:2,children:[]},{name:"阻止放入",id:"阻止放入",level:2,children:[]},{name:"拖拽过程中的运行时数据",id:"拖拽过程中的运行时数据",level:2,children:[]},{name:"占位元素",id:"占位元素",level:2,children:[]},{name:"拖拽到节点上时打开该节点",id:"拖拽到节点上时打开该节点",level:2,children:[]},{name:"拖拽节点的定位",id:"拖拽节点的定位",level:2,children:[]},{name:"边缘滚动",id:"边缘滚动",level:2,children:[]},{name:"触摸",id:"触摸",level:2,children:[]},{name:"最大层级",id:"最大层级",level:2,children:[]},{name:"Pro 插件(需购买)",id:"pro-插件需购买",level:2,children:[]},{name:"通过 script 标签引入",id:"通过-script-标签引入",level:2,children:[]}]};g(i.name,a),p.value=i.children||[],v(()=>{p.value=null})}},y={class:"docs-view"},b={class:"article mt-14 mb-8 prose"},L=n("p",null,[n("strong",null,"使用 Vue2 时把下面文档的 3 替换为 2.")],-1),$=n("p",null,[e("你可能需要设置节点之间的距离, 不要使用"),n("code",null,"margin-bottom"),e("来实现. 否则组件不能得到节点的真实高度. 使用 prop "),n("code",null,"gap"),e(" 替代.")],-1),T=n("p",null,[e("该组件可以传入树形数据或扁平数据. 传入树形数据(treeData)时, 需指定 "),n("code",null,"childrenKey"),e(". 传入扁平数据(flatData)时, 需指定 "),n("code",null,"idKey"),e(", "),n("code",null,"parentIdKey"),e(".")],-1),C=n("p",null,[n("code",null,"treeData"),e(" 示例:")],-1),N=n("p",null,[n("code",null,"flatData"),e(" 示例:")],-1),B=c("<p><strong>该组件渲染为列表而不是树形结构. 不同层级的节点有不同的 <code>padding-left</code>.</strong> 参考此结构, 你可以做下面的事:</p><ul><li>设置 <code>node.$outerClass</code> 和 <code>node.$outerStyle</code>来控制 tree-node-outer 元素 的 class 和 style.</li><li>设置 <code>node.$nodeClass</code> 和 <code>node.$nodeStyle</code>来控制 tree-node 元素 的 class 和 style.</li><li>使用默认插槽来定制节点外观. 该插槽参数: node, tree.</li></ul>",2),V=n("code",null,"outputNestedData",-1),z=n("code",null,"outputFlatData",-1),K=n("code",null,"drop",-1),S=n("code",null,"drop-change",-1),M=n("p",null,[e("展开节点时加载其子节点数据. 例如通过 Ajax. 使用 prop "),n("code",null,"childrenLazyLoading"),e(" 启用. prop "),n("code",null,"childrenLoader"),e(" 是加载时调用的方法, 可以返回 "),n("code",null,"Promise"),e(", 返回的数据只能是树形数据.")],-1),H=n("p",null,[e("使用 prop "),n("code",null,"defaultFolded"),e(" 控制.")],-1),k=n("p",null,[e("使用方法 "),n("code",null,"getAllCheckedNodes"),e(" 以获得所有勾选的节点.")],-1),P=n("p",null,[e("从右到左显示. 使用 prop "),n("code",null,"rtl"),e(" 控制.")],-1),j=n("p",null,[e("此功能可以在有许多节点时提高渲染性能. 使用 prop "),n("code",null,"virtualization"),e(" 启用. 使用 prop "),n("code",null,"virtualizationPrerender"),e(" 设置开始时显示的节点数量.")],-1),w=n("p",null,[e("一定要给树添加样式"),n("code",null,"overflow:auto"),e(", 并指定高度, 可以设置固定值, 也可以使用 max-height 或者 flex 动态设置高度.")],-1),I=n("p",null,"使用以下代码手动更新虚拟列表:",-1),A=n("p",null,[e("使用 prop "),n("code",null,"triggerClass"),e(" 指定触发拖拽的元素的 css class. 当 prop "),n("code",null,"triggerBySelf"),e(" 为 true 时, 它的子元素将不能触发拖拽.")],-1),F=c("<ul><li>当 prop <code>draggable</code> 为 false, 此树的任一节点不能被拖拽.</li><li>使用 prop <code>eachDraggable</code> 在拖拽开始时.</li><li>当 prop <code>rootDraggable</code> 为 false, 顶级节点(level 1) 不能被拖拽.</li><li>使用 prop <code>ondragstart</code> 在拖拽开始时.</li><li>设置 <code>node.$draggable</code> 为 false 控制单个节点是否可拖拽.</li><li>当父节点不可拖拽而子节点可拖拽时, 例如设置 子节点的 <code>$draggable</code> 为 true, 子节点可以拖拽.</li></ul>",1),R=c("<ul><li>当 prop <code>droppable</code> 为 false, 任一节点不能放入这棵树.</li><li>使用 prop <code>eachDroppable</code> 当拖动到一节点上时.</li><li>当 prop <code>rootDroppable</code> 为 false, 被拖拽的节点不能成为顶级节点.</li><li>使用 prop <code>ondragend</code> 在拖拽结束时, 若返回 false, 则恢复拖拽前的原状. 支持 promise.</li><li>设置 <code>node.$droppable</code> 为 false 控制单个节点是否可放入.</li><li>当父节点不可放入而子节点可放入时, 例如设置子节点的 <code>$droppable</code> 为 true, 则此子节点可放入.</li></ul>",1),W=n("code",null,"tree.store",-1),E=n("p",null,[e("拖拽时, 会生成一个元素默认淡青色背景, 用以标识可放置的位置. 使用 prop "),n("code",null,"afterPlaceholderCreated"),e(" 修改它. 如果想操作此元素比如添加文字, 只能通过原生 js 操作.")],-1),U=n("code",null,"unfoldWhenDragover",-1),q=n("code",null,"edgeScroll",-1),G=n("p",null,[e("支持触摸设备. 触摸拖拽时将会阻止默认行为, 但是有时无效. 所以请添加如下 css 阻止触摸时的默认行为例如滚动屏幕. css 目标是触发拖拽的元素. 如果未特别指定触发拖拽的元素, 则由"),n("code",null,"tree-node"),e("触发.")],-1),J=n("p",null,[e("拖拽时限制树的最大层级. 可使用 prop "),n("code",null,"eachDroppable"),e(". 下面示例代码支持 Vue2 和 Vue3.")],-1),O=n("p",null,[n("a",{href:"/pro"},"pro 插件"),e(" 有以下高级功能.")],-1),Q=n("ul",null,[n("li",null,"跨树拖拽."),n("li",null,"拖拽开始时克隆原节点而不是移动原节点.")],-1),X=n("p",null,[e("从 npm 下载最新版本, 上传 "),n("code",null,"dist"),e(" 文件夹到你的服务器.")],-1),Y=n("p",null,[e("通过全局变量 "),n("code",null,"heTreeVue3"),e(" 或 "),n("code",null,"heTreeVue2"),e(" 访问此库.")],-1);function Z(a,i,ee,ne,le,de){const t=s("vheading"),o=s("CodeContainer"),r=s("Anchor");return _(),f("div",y,[n("div",b,[l(t,{level:1,id:"教程"},{default:d(()=>[e("教程")]),_:1}),L,l(t,{level:2,id:"安装"},{default:d(()=>[e("安装")]),_:1}),l(o,{codeLanguage:"sh",code:"# Vue3\nnpm i -P @he-tree/vue3\n# Vue2\nnpm i -P @he-tree/vue2\n"}),l(t,{level:2,id:"引入"},{default:d(()=>[e("引入")]),_:1}),l(o,{codeLanguage:"ts",code:"import { BaseTree, Draggable, obj, BaseNode, Node } from '@he-tree/vue3'\nimport '@he-tree/vue3/dist/he-tree-vue3.css'\n"}),l(t,{level:2,id:"不要给节点设置外边距"},{default:d(()=>[e("不要给节点设置外边距")]),_:1}),$,l(t,{level:2,id:"treedata-或-flatdata"},{default:d(()=>[e("treeData 或 flatData")]),_:1}),T,C,l(o,{codeLanguage:"ts",code:"treeData = [\n  {\n    text: 'node1',\n    children: [{ text: 'node1-1' }, { text: 'node1-2' }, { text: 'node1-3' }],\n  },\n  { text: 'node2' },\n]\n"}),N,l(o,{codeLanguage:"ts",code:"flatData = [\n  { text: 'node1', id: 1 },\n  { text: 'node2', id: 2 },\n  { text: 'node1-1', id: 3, pid: 1 },\n  { text: 'node1-2', id: 3, pid: 1 },\n  { text: 'node1-3', id: 3, pid: 1 },\n]\n"}),l(t,{level:2,id:"html-结构"},{default:d(()=>[e("HTML 结构")]),_:1}),l(o,{codeLanguage:"pug",code:'.he-tree(:id="treeID" :class="{\'he-tree-dragging\':dragging, \'he-tree-rtl\': rtl}")\n  .vl-items\n    .tree-node-outer(:data-id="node.$id" :class="node.$outerClass" :style="node.$outerClass")\n      .tree-node(:class="node.$nodeClass" :style="node.$nodeStyle")\n        slot(:node="node" :tree="tree") {{node[textKey]}}\n    .tree-node-outer(:data-id="node.$id" :class="node.$outerClass" :style="node.$outerClass")\n      .tree-node(:class="node.$nodeClass" :style="node.$nodeStyle")\n        slot(:node="node" :tree="tree") {{node[textKey]}}\n    ...\n'}),B,l(t,{level:2,id:"使用"},{default:d(()=>[e("使用")]),_:1}),l(o,{codeLanguage:"vue",code:"<template>\n  <BaseTree :flatData=\"flatData\" idKey=\"id\" parentIdKey=\"pid\" />\n</template>\n<script>\n  import '@he-tree/vue3/dist/he-tree-vue3.css'\n  import { BaseTree } from '@he-tree/vue3'\n\n  export default {\n    components: { BaseTree },\n    data() {\n      return {\n        flatData: [\n          { text: 'node1', id: 1 },\n          { text: 'node2', id: 2 },\n          { text: 'node1-1', id: 3, pid: 1 },\n          { text: 'node1-2', id: 3, pid: 1 },\n          { text: 'node1-3', id: 3, pid: 1 },\n        ],\n      }\n    },\n  }\n<\/script>\n"}),l(t,{level:2,id:"输出数据"},{default:d(()=>[e("输出数据")]),_:1}),n("p",null,[e("使用方法 "),V,e(" 和 "),z,e(" 以获得树形数据或扁平数据. 在拖拽时为了获得改变后的数据, 可以在"),l(r,{to:a.resolveHref("/zh/v1/api#drop"),underline:""},{default:d(()=>[K]),_:1},8,["to"]),e(" 或 "),l(r,{to:a.resolveHref("/zh/v1/api#drop-change"),underline:""},{default:d(()=>[S]),_:1},8,["to"]),e("事件中执行它们.")]),l(t,{level:2,id:"折叠和展开"},{default:d(()=>[e("折叠和展开")]),_:1}),l(o,{codeLanguage:"vue",code:"<template>\n  <BaseTree :flatData=\"flatData\" idKey=\"id\" parentIdKey=\"pid\">\n    <template v-slot=\"{ node, tree }\">\n      <b @click=\"tree.toggleFold(node)\">{{ node.$folded ? '+' : '-' }}</b>\n      <span>{{ node.text }}</span>\n    </template>\n  </BaseTree>\n</template>\n<script>\n  import '@he-tree/vue3/dist/he-tree-vue3.css'\n  import { BaseTree } from '@he-tree/vue3'\n\n  export default {\n    components: { BaseTree },\n    data() {\n      return {\n        flatData: [\n          { text: 'node1', id: 1 },\n          { text: 'node2', id: 2 },\n          { text: 'node1-1', id: 3, pid: 1 },\n          { text: 'node1-2', id: 3, pid: 1 },\n          { text: 'node1-3', id: 3, pid: 1 },\n        ],\n      }\n    },\n  }\n<\/script>\n"}),l(t,{level:2,id:"按需加载子节点"},{default:d(()=>[e("按需加载子节点")]),_:1}),M,l(t,{level:2,id:"默认折叠所有节点"},{default:d(()=>[e("默认折叠所有节点")]),_:1}),H,l(t,{level:2,id:"勾选框"},{default:d(()=>[e("勾选框")]),_:1}),k,l(o,{codeLanguage:"vue",code:"<template>\n  <BaseTree :flatData=\"flatData\" idKey=\"id\" parentIdKey=\"pid\">\n    <template v-slot=\"{ node, tree }\">\n      <input\n        type=\"checkbox\"\n        v-model=\"node.$checked\"\n        @change=\"tree.updateChecked(node)\"\n      />\n      <span>{{ node.text }}</span>\n    </template>\n  </BaseTree>\n</template>\n<script>\n  import '@he-tree/vue3/dist/he-tree-vue3.css'\n  import { BaseTree } from '@he-tree/vue3'\n\n  export default {\n    components: { BaseTree },\n    data() {\n      return {\n        flatData: [\n          { text: 'node1', id: 1 },\n          { text: 'node2', id: 2 },\n          { text: 'node1-1', id: 3, pid: 1 },\n          { text: 'node1-2', id: 3, pid: 1 },\n          { text: 'node1-3', id: 3, pid: 1 },\n        ],\n      }\n    },\n  }\n<\/script>\n"}),l(t,{level:2,id:"rtl"},{default:d(()=>[e("RTL")]),_:1}),P,l(t,{level:2,id:"虚拟列表"},{default:d(()=>[e("虚拟列表")]),_:1}),j,w,l(o,{codeLanguage:"html",code:'<Draggable virtualization style="height:300px;overflow:auto" />\n'}),I,l(o,{codeLanguage:"js",code:"tree.$refs.virtualizationList.update()\n"}),l(t,{level:2,id:"拖拽"},{default:d(()=>[e("拖拽")]),_:1}),l(o,{codeLanguage:"vue",code:"<template>\n  <Draggable :flatData=\"flatData\" idKey=\"id\" parentIdKey=\"pid\" />\n</template>\n<script>\n  import '@he-tree/vue3/dist/he-tree-vue3.css'\n  import { Draggable } from '@he-tree/vue3'\n\n  export default {\n    components: { Draggable },\n    data() {\n      return {\n        flatData: [\n          { text: 'node1', id: 1 },\n          { text: 'node2', id: 2 },\n          { text: 'node1-1', id: 3, pid: 1 },\n          { text: 'node1-2', id: 3, pid: 1 },\n          { text: 'node1-3', id: 3, pid: 1 },\n        ],\n      }\n    },\n  }\n<\/script>\n"}),l(t,{level:2,id:"拖拽触发"},{default:d(()=>[e("拖拽触发")]),_:1}),A,l(t,{level:2,id:"阻止拖拽"},{default:d(()=>[e("阻止拖拽")]),_:1}),F,l(t,{level:2,id:"阻止放入"},{default:d(()=>[e("阻止放入")]),_:1}),R,l(t,{level:2,id:"拖拽过程中的运行时数据"},{default:d(()=>[e("拖拽过程中的运行时数据")]),_:1}),n("p",null,[e("参考 "),l(r,{to:a.resolveHref("/zh/v1/api#store"),underline:""},{default:d(()=>[W]),_:1},8,["to"])]),l(t,{level:2,id:"占位元素"},{default:d(()=>[e("占位元素")]),_:1}),E,l(t,{level:2,id:"拖拽到节点上时打开该节点"},{default:d(()=>[e("拖拽到节点上时打开该节点")]),_:1}),n("p",null,[e("当把节点拖动到一个折叠节点上时, 默认会打开此节点以便拖入其中. 可通过 prop "),U,e("控制. 相关 prop: "),l(r,{to:a.resolveHref("/zh/v1/api#unfoldwhendragoverdelay"),underline:""},{default:d(()=>[e("unfoldWhenDragoverDelay")]),_:1},8,["to"])]),l(t,{level:2,id:"拖拽节点的定位"},{default:d(()=>[e("拖拽节点的定位")]),_:1}),n("p",null,[e("默认使用拖拽节点的左上角坐标来定位, 也可以设置使用鼠标位置来定位. "),l(r,{to:a.resolveHref("/zh/v1/api#draggingnodepositionmode"),underline:""},{default:d(()=>[e("draggingNodePositionMode")]),_:1},8,["to"])]),l(t,{level:2,id:"边缘滚动"},{default:d(()=>[e("边缘滚动")]),_:1}),n("p",null,[e("这是属于拖拽插件的功能. 如果树处在一个滚动框中, 拖拽到其边缘时需要自动滚动. 此项默认关闭, 使用 prop"),q,e("开启. 相关 prop: "),l(r,{to:a.resolveHref("/zh/v1/api#edgescrolltriggermargin"),underline:""},{default:d(()=>[e("edgeScrollTriggerMargin")]),_:1},8,["to"]),e(", "),l(r,{to:a.resolveHref("/zh/v1/api#edgescrollspeed"),underline:""},{default:d(()=>[e("edgeScrollSpeed")]),_:1},8,["to"]),e(", "),l(r,{to:a.resolveHref("/zh/v1/api#edgescrolltriggermode"),underline:""},{default:d(()=>[e("edgeScrollTriggerMode")]),_:1},8,["to"]),e(".")]),l(t,{level:2,id:"触摸"},{default:d(()=>[e("触摸")]),_:1}),G,l(o,{codeLanguage:"css",code:"touch-action: none;\n"}),l(t,{level:2,id:"最大层级"},{default:d(()=>[e("最大层级")]),_:1}),J,l(o,{codeLanguage:"html",code:'<Draggable :eachDroppable="eachDroppable" />\n'}),l(o,{codeLanguage:"js",code:'data() {\n  return {\n    eachDroppable: (node, store, options, startTree) => {\n      const maxLevel = 3; // 按你需要修改\n      let draggingNodeMaxLevel = 0;\n      hp.walkTreeData(\n        store.draggingNode,\n        (childNode) => {\n          if (childNode.$level > draggingNodeMaxLevel) {\n            draggingNodeMaxLevel = childNode.$level;\n          }\n        },\n        "$children"\n      );\n      draggingNodeMaxLevel = draggingNodeMaxLevel - store.draggingNode.$level;\n      if (node.$level + draggingNodeMaxLevel >= maxLevel) {\n        return false;\n      }\n    },\n  }\n}\n'}),l(t,{level:2,id:"pro-插件需购买"},{default:d(()=>[e("Pro 插件(需购买)")]),_:1}),O,Q,l(t,{level:2,id:"通过-script-标签引入"},{default:d(()=>[e("通过 script 标签引入")]),_:1}),X,l(o,{codeLanguage:"html",code:'<!-- replace vue3 to vue2 if use Vue2 -->\n<script src="yourpath/dist/he-tree-vue3.min.js" charset="utf-8"><\/script>\n<link rel="stylesheet" href="yourpath/dist/he-tree-vue3.css" />\n<!-- usage -->\n<script type="text/javascript">\n  var Tree = heTreeVue3.BaseTree;\n  var Fold = heTreeVue3.Draggable;\n  ...\n<\/script>\n'}),Y])])}const ae=u(D,[["render",Z]]);export{ae as default};
