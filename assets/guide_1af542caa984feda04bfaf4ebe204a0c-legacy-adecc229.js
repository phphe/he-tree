System.register(["./index-legacy-be5d2fb8.js","./CodeContainer-legacy-9e5acd0c.js"],(function(e,l){"use strict";var n,d,t,o,a,r,i,c,u,p,s,g,v,h,f;return{setters:[e=>{n=e._,d=e.g,t=e.u,o=e.f,a=e.h,r=e.r,i=e.c,c=e.a,u=e.b,p=e.w,s=e.e,g=e.i,v=e.o},e=>{h=e._,f=e.C}],execute:function(){const l={extends:h,components:{CodeContainer:f},setup(){const e=d(),l={name:"教程",id:"教程",level:1,children:[{name:"安装",id:"安装",level:2,children:[]},{name:"引入",id:"引入",level:2,children:[]},{name:"不要给节点设置外边距",id:"不要给节点设置外边距",level:2,children:[]},{name:"treeData 或 flatData",id:"treedata-或-flatdata",level:2,children:[]},{name:"HTML 结构",id:"html-结构",level:2,children:[]},{name:"使用",id:"使用",level:2,children:[]},{name:"输出数据",id:"输出数据",level:2,children:[]},{name:"折叠和展开",id:"折叠和展开",level:2,children:[]},{name:"按需加载子节点",id:"按需加载子节点",level:2,children:[]},{name:"默认折叠所有节点",id:"默认折叠所有节点",level:2,children:[]},{name:"勾选框",id:"勾选框",level:2,children:[]},{name:"RTL",id:"rtl",level:2,children:[]},{name:"虚拟列表",id:"虚拟列表",level:2,children:[]},{name:"拖拽",id:"拖拽",level:2,children:[]},{name:"拖拽触发",id:"拖拽触发",level:2,children:[]},{name:"阻止拖拽",id:"阻止拖拽",level:2,children:[]},{name:"阻止放入",id:"阻止放入",level:2,children:[]},{name:"拖拽过程中的运行时数据",id:"拖拽过程中的运行时数据",level:2,children:[]},{name:"占位元素",id:"占位元素",level:2,children:[]},{name:"拖拽到节点上时打开该节点",id:"拖拽到节点上时打开该节点",level:2,children:[]},{name:"拖拽节点的定位",id:"拖拽节点的定位",level:2,children:[]},{name:"边缘滚动",id:"边缘滚动",level:2,children:[]},{name:"触摸",id:"触摸",level:2,children:[]},{name:"最大层级",id:"最大层级",level:2,children:[]},{name:"Pro 插件(需购买)",id:"pro-插件需购买",level:2,children:[]},{name:"通过 script 标签引入",id:"通过-script-标签引入",level:2,children:[]}]}||{};t(l.name,e),o.value=l.children||[],a((()=>{o.value=null}))}},m={class:"docs-view"},x={class:"article mt-14 mb-8 prose"},D=c("p",null,[c("strong",null,"使用 Vue2 时把下面文档的 3 替换为 2.")],-1),_=c("p",null,[s("你可能需要设置节点之间的距离, 不要使用"),c("code",null,"margin-bottom"),s("来实现. 否则组件不能得到节点的真实高度. 使用 prop "),c("code",null,"gap"),s(" 替代.")],-1),y=c("p",null,[s("该组件可以传入树形数据或扁平数据. 传入树形数据(treeData)时, 需指定 "),c("code",null,"childrenKey"),s(". 传入扁平数据(flatData)时, 需指定 "),c("code",null,"idKey"),s(", "),c("code",null,"parentIdKey"),s(".")],-1),L=c("p",null,[c("code",null,"treeData"),s(" 示例:")],-1),b=c("p",null,[c("code",null,"flatData"),s(" 示例:")],-1),T=g("<p><strong>该组件渲染为列表而不是树形结构. 不同层级的节点有不同的 <code>padding-left</code>.</strong> 参考此结构, 你可以做下面的事:</p><ul><li>设置 <code>node.$outerClass</code> 和 <code>node.$outerStyle</code>来控制 tree-node-outer 元素 的 class 和 style.</li><li>设置 <code>node.$nodeClass</code> 和 <code>node.$nodeStyle</code>来控制 tree-node 元素 的 class 和 style.</li><li>使用默认插槽来定制节点外观. 该插槽参数: node, tree.</li></ul>",2),$=c("code",null,"outputNestedData",-1),C=c("code",null,"outputFlatData",-1),N=c("code",null,"drop",-1),B=c("code",null,"drop-change",-1),z=c("p",null,[s("展开节点时加载其子节点数据. 例如通过 Ajax. 使用 prop "),c("code",null,"childrenLazyLoading"),s(" 启用. prop "),c("code",null,"childrenLoader"),s(" 是加载时调用的方法, 可以返回 "),c("code",null,"Promise"),s(", 返回的数据只能是树形数据.")],-1),K=c("p",null,[s("使用 prop "),c("code",null,"defaultFolded"),s(" 控制.")],-1),M=c("p",null,[s("使用方法 "),c("code",null,"getAllCheckedNodes"),s(" 以获得所有勾选的节点.")],-1),S=c("p",null,[s("从右到左显示. 使用 prop "),c("code",null,"rtl"),s(" 控制.")],-1),H=c("p",null,[s("此功能可以在有许多节点时提高渲染性能. 使用 prop "),c("code",null,"virtualization"),s(" 启用. 使用 prop "),c("code",null,"virtualizationPrerender"),s(" 设置开始时显示的节点数量.")],-1),V=c("p",null,[s("一定要给树添加样式"),c("code",null,"overflow:auto"),s(", 并指定高度, 可以设置固定值, 也可以使用 max-height 或者 flex 动态设置高度.")],-1),j=c("p",null,"使用以下代码手动更新虚拟列表:",-1),P=c("p",null,[s("使用 prop "),c("code",null,"triggerClass"),s(" 指定触发拖拽的元素的 css class. 当 prop "),c("code",null,"triggerBySelf"),s(" 为 true 时, 它的子元素将不能触发拖拽.")],-1),k=g("<ul><li>当 prop <code>draggable</code> 为 false, 此树的任一节点不能被拖拽.</li><li>使用 prop <code>eachDraggable</code> 在拖拽开始时.</li><li>当 prop <code>rootDraggable</code> 为 false, 顶级节点(level 1) 不能被拖拽.</li><li>使用 prop <code>ondragstart</code> 在拖拽开始时.</li><li>设置 <code>node.$draggable</code> 为 false 控制单个节点是否可拖拽.</li><li>当父节点不可拖拽而子节点可拖拽时, 例如设置 子节点的 <code>$draggable</code> 为 true, 子节点可以拖拽.</li></ul>",1),w=g("<ul><li>当 prop <code>droppable</code> 为 false, 任一节点不能放入这棵树.</li><li>使用 prop <code>eachDroppable</code> 当拖动到一节点上时.</li><li>当 prop <code>rootDroppable</code> 为 false, 被拖拽的节点不能成为顶级节点.</li><li>使用 prop <code>ondragend</code> 在拖拽结束时, 若返回 false, 则恢复拖拽前的原状. 支持 promise.</li><li>设置 <code>node.$droppable</code> 为 false 控制单个节点是否可放入.</li><li>当父节点不可放入而子节点可放入时, 例如设置子节点的 <code>$droppable</code> 为 true, 则此子节点可放入.</li></ul>",1),I=c("code",null,"tree.store",-1),F=c("p",null,[s("拖拽时, 会生成一个元素默认淡青色背景, 用以标识可放置的位置. 使用 prop "),c("code",null,"afterPlaceholderCreated"),s(" 修改它. 如果想操作此元素比如添加文字, 只能通过原生 js 操作.")],-1),A=c("code",null,"unfoldWhenDragover",-1),R=c("code",null,"edgeScroll",-1),W=c("p",null,[s("支持触摸设备. 触摸拖拽时将会阻止默认行为, 但是有时无效. 所以请添加如下 css 阻止触摸时的默认行为例如滚动屏幕. css 目标是触发拖拽的元素. 如果未特别指定触发拖拽的元素, 则由"),c("code",null,"tree-node"),s("触发.")],-1),q=c("p",null,[s("拖拽时限制树的最大层级. 可使用 prop "),c("code",null,"eachDroppable"),s(". 下面示例代码支持 Vue2 和 Vue3.")],-1),E=c("p",null,[c("a",{href:"/pro"},"pro 插件"),s(" 有以下高级功能.")],-1),G=c("ul",null,[c("li",null,"跨树拖拽."),c("li",null,"拖拽开始时克隆原节点而不是移动原节点.")],-1),J=c("p",null,[s("从 npm 下载最新版本, 上传 "),c("code",null,"dist"),s(" 文件夹到你的服务器.")],-1),O=c("p",null,[s("通过全局变量 "),c("code",null,"heTreeVue3"),s(" 或 "),c("code",null,"heTreeVue2"),s(" 访问此库.")],-1);e("default",n(l,[["render",function(e,l,n,d,t,o){const a=r("vheading"),g=r("CodeContainer"),h=r("Anchor");return v(),i("div",m,[c("div",x,[u(a,{level:1,id:"教程"},{default:p((()=>[s("教程")])),_:1}),D,u(a,{level:2,id:"安装"},{default:p((()=>[s("安装")])),_:1}),u(g,{codeLanguage:"sh",code:"# Vue3\nnpm i -P @he-tree/vue3\n# Vue2\nnpm i -P @he-tree/vue2\n"}),u(a,{level:2,id:"引入"},{default:p((()=>[s("引入")])),_:1}),u(g,{codeLanguage:"ts",code:"import { BaseTree, Draggable, obj, BaseNode, Node } from '@he-tree/vue3'\nimport '@he-tree/vue3/dist/he-tree-vue3.css'\n"}),u(a,{level:2,id:"不要给节点设置外边距"},{default:p((()=>[s("不要给节点设置外边距")])),_:1}),_,u(a,{level:2,id:"treedata-或-flatdata"},{default:p((()=>[s("treeData 或 flatData")])),_:1}),y,L,u(g,{codeLanguage:"ts",code:"treeData = [\n  {\n    text: 'node1',\n    children: [{ text: 'node1-1' }, { text: 'node1-2' }, { text: 'node1-3' }],\n  },\n  { text: 'node2' },\n]\n"}),b,u(g,{codeLanguage:"ts",code:"flatData = [\n  { text: 'node1', id: 1 },\n  { text: 'node2', id: 2 },\n  { text: 'node1-1', id: 3, pid: 1 },\n  { text: 'node1-2', id: 3, pid: 1 },\n  { text: 'node1-3', id: 3, pid: 1 },\n]\n"}),u(a,{level:2,id:"html-结构"},{default:p((()=>[s("HTML 结构")])),_:1}),u(g,{codeLanguage:"pug",code:'.he-tree(:id="treeID" :class="{\'he-tree-dragging\':dragging, \'he-tree-rtl\': rtl}")\n  .vl-items\n    .tree-node-outer(:data-id="node.$id" :class="node.$outerClass" :style="node.$outerClass")\n      .tree-node(:class="node.$nodeClass" :style="node.$nodeStyle")\n        slot(:node="node" :tree="tree") {{node[textKey]}}\n    .tree-node-outer(:data-id="node.$id" :class="node.$outerClass" :style="node.$outerClass")\n      .tree-node(:class="node.$nodeClass" :style="node.$nodeStyle")\n        slot(:node="node" :tree="tree") {{node[textKey]}}\n    ...\n'}),T,u(a,{level:2,id:"使用"},{default:p((()=>[s("使用")])),_:1}),u(g,{codeLanguage:"vue",code:"<template>\n  <BaseTree :flatData=\"flatData\" idKey=\"id\" parentIdKey=\"pid\" />\n</template>\n<script>\n  import '@he-tree/vue3/dist/he-tree-vue3.css'\n  import { BaseTree } from '@he-tree/vue3'\n\n  export default {\n    components: { BaseTree },\n    data() {\n      return {\n        flatData: [\n          { text: 'node1', id: 1 },\n          { text: 'node2', id: 2 },\n          { text: 'node1-1', id: 3, pid: 1 },\n          { text: 'node1-2', id: 3, pid: 1 },\n          { text: 'node1-3', id: 3, pid: 1 },\n        ],\n      }\n    },\n  }\n<\/script>\n"}),u(a,{level:2,id:"输出数据"},{default:p((()=>[s("输出数据")])),_:1}),c("p",null,[s("使用方法 "),$,s(" 和 "),C,s(" 以获得树形数据或扁平数据. 在拖拽时为了获得改变后的数据, 可以在"),u(h,{to:e.resolveHref("/zh/v1/api#drop"),underline:""},{default:p((()=>[N])),_:1},8,["to"]),s(" 或 "),u(h,{to:e.resolveHref("/zh/v1/api#drop-change"),underline:""},{default:p((()=>[B])),_:1},8,["to"]),s("事件中执行它们.")]),u(a,{level:2,id:"折叠和展开"},{default:p((()=>[s("折叠和展开")])),_:1}),u(g,{codeLanguage:"vue",code:"<template>\n  <BaseTree :flatData=\"flatData\" idKey=\"id\" parentIdKey=\"pid\">\n    <template v-slot=\"{ node, tree }\">\n      <b @click=\"tree.toggleFold(node)\">{{ node.$folded ? '+' : '-' }}</b>\n      <span>{{ node.text }}</span>\n    </template>\n  </BaseTree>\n</template>\n<script>\n  import '@he-tree/vue3/dist/he-tree-vue3.css'\n  import { BaseTree } from '@he-tree/vue3'\n\n  export default {\n    components: { BaseTree },\n    data() {\n      return {\n        flatData: [\n          { text: 'node1', id: 1 },\n          { text: 'node2', id: 2 },\n          { text: 'node1-1', id: 3, pid: 1 },\n          { text: 'node1-2', id: 3, pid: 1 },\n          { text: 'node1-3', id: 3, pid: 1 },\n        ],\n      }\n    },\n  }\n<\/script>\n"}),u(a,{level:2,id:"按需加载子节点"},{default:p((()=>[s("按需加载子节点")])),_:1}),z,u(a,{level:2,id:"默认折叠所有节点"},{default:p((()=>[s("默认折叠所有节点")])),_:1}),K,u(a,{level:2,id:"勾选框"},{default:p((()=>[s("勾选框")])),_:1}),M,u(g,{codeLanguage:"vue",code:"<template>\n  <BaseTree :flatData=\"flatData\" idKey=\"id\" parentIdKey=\"pid\">\n    <template v-slot=\"{ node, tree }\">\n      <input\n        type=\"checkbox\"\n        v-model=\"node.$checked\"\n        @change=\"tree.updateChecked(node)\"\n      />\n      <span>{{ node.text }}</span>\n    </template>\n  </BaseTree>\n</template>\n<script>\n  import '@he-tree/vue3/dist/he-tree-vue3.css'\n  import { BaseTree } from '@he-tree/vue3'\n\n  export default {\n    components: { BaseTree },\n    data() {\n      return {\n        flatData: [\n          { text: 'node1', id: 1 },\n          { text: 'node2', id: 2 },\n          { text: 'node1-1', id: 3, pid: 1 },\n          { text: 'node1-2', id: 3, pid: 1 },\n          { text: 'node1-3', id: 3, pid: 1 },\n        ],\n      }\n    },\n  }\n<\/script>\n"}),u(a,{level:2,id:"rtl"},{default:p((()=>[s("RTL")])),_:1}),S,u(a,{level:2,id:"虚拟列表"},{default:p((()=>[s("虚拟列表")])),_:1}),H,V,u(g,{codeLanguage:"html",code:'<Draggable virtualization style="height:300px;overflow:auto" />\n'}),j,u(g,{codeLanguage:"js",code:"tree.$refs.virtualizationList.update()\n"}),u(a,{level:2,id:"拖拽"},{default:p((()=>[s("拖拽")])),_:1}),u(g,{codeLanguage:"vue",code:"<template>\n  <Draggable :flatData=\"flatData\" idKey=\"id\" parentIdKey=\"pid\" />\n</template>\n<script>\n  import '@he-tree/vue3/dist/he-tree-vue3.css'\n  import { Draggable } from '@he-tree/vue3'\n\n  export default {\n    components: { Draggable },\n    data() {\n      return {\n        flatData: [\n          { text: 'node1', id: 1 },\n          { text: 'node2', id: 2 },\n          { text: 'node1-1', id: 3, pid: 1 },\n          { text: 'node1-2', id: 3, pid: 1 },\n          { text: 'node1-3', id: 3, pid: 1 },\n        ],\n      }\n    },\n  }\n<\/script>\n"}),u(a,{level:2,id:"拖拽触发"},{default:p((()=>[s("拖拽触发")])),_:1}),P,u(a,{level:2,id:"阻止拖拽"},{default:p((()=>[s("阻止拖拽")])),_:1}),k,u(a,{level:2,id:"阻止放入"},{default:p((()=>[s("阻止放入")])),_:1}),w,u(a,{level:2,id:"拖拽过程中的运行时数据"},{default:p((()=>[s("拖拽过程中的运行时数据")])),_:1}),c("p",null,[s("参考 "),u(h,{to:e.resolveHref("/zh/v1/api#store"),underline:""},{default:p((()=>[I])),_:1},8,["to"])]),u(a,{level:2,id:"占位元素"},{default:p((()=>[s("占位元素")])),_:1}),F,u(a,{level:2,id:"拖拽到节点上时打开该节点"},{default:p((()=>[s("拖拽到节点上时打开该节点")])),_:1}),c("p",null,[s("当把节点拖动到一个折叠节点上时, 默认会打开此节点以便拖入其中. 可通过 prop "),A,s("控制. 相关 prop: "),u(h,{to:e.resolveHref("/zh/v1/api#unfoldwhendragoverdelay"),underline:""},{default:p((()=>[s("unfoldWhenDragoverDelay")])),_:1},8,["to"])]),u(a,{level:2,id:"拖拽节点的定位"},{default:p((()=>[s("拖拽节点的定位")])),_:1}),c("p",null,[s("默认使用拖拽节点的左上角坐标来定位, 也可以设置使用鼠标位置来定位. "),u(h,{to:e.resolveHref("/zh/v1/api#draggingnodepositionmode"),underline:""},{default:p((()=>[s("draggingNodePositionMode")])),_:1},8,["to"])]),u(a,{level:2,id:"边缘滚动"},{default:p((()=>[s("边缘滚动")])),_:1}),c("p",null,[s("这是属于拖拽插件的功能. 如果树处在一个滚动框中, 拖拽到其边缘时需要自动滚动. 此项默认关闭, 使用 prop"),R,s("开启. 相关 prop: "),u(h,{to:e.resolveHref("/zh/v1/api#edgescrolltriggermargin"),underline:""},{default:p((()=>[s("edgeScrollTriggerMargin")])),_:1},8,["to"]),s(", "),u(h,{to:e.resolveHref("/zh/v1/api#edgescrollspeed"),underline:""},{default:p((()=>[s("edgeScrollSpeed")])),_:1},8,["to"]),s(", "),u(h,{to:e.resolveHref("/zh/v1/api#edgescrolltriggermode"),underline:""},{default:p((()=>[s("edgeScrollTriggerMode")])),_:1},8,["to"]),s(".")]),u(a,{level:2,id:"触摸"},{default:p((()=>[s("触摸")])),_:1}),W,u(g,{codeLanguage:"css",code:"touch-action: none;\n"}),u(a,{level:2,id:"最大层级"},{default:p((()=>[s("最大层级")])),_:1}),q,u(g,{codeLanguage:"html",code:'<Draggable :eachDroppable="eachDroppable" />\n'}),u(g,{codeLanguage:"js",code:'data() {\n  return {\n    eachDroppable: (node, store, options, startTree) => {\n      const maxLevel = 3; // 按你需要修改\n      let draggingNodeMaxLevel = 0;\n      hp.walkTreeData(\n        store.draggingNode,\n        (childNode) => {\n          if (childNode.$level > draggingNodeMaxLevel) {\n            draggingNodeMaxLevel = childNode.$level;\n          }\n        },\n        "$children"\n      );\n      draggingNodeMaxLevel = draggingNodeMaxLevel - store.draggingNode.$level;\n      if (node.$level + draggingNodeMaxLevel >= maxLevel) {\n        return false;\n      }\n    },\n  }\n}\n'}),u(a,{level:2,id:"pro-插件需购买"},{default:p((()=>[s("Pro 插件(需购买)")])),_:1}),E,G,u(a,{level:2,id:"通过-script-标签引入"},{default:p((()=>[s("通过 script 标签引入")])),_:1}),J,u(g,{codeLanguage:"html",code:'\x3c!-- replace vue3 to vue2 if use Vue2 --\x3e\n<script src="yourpath/dist/he-tree-vue3.min.js" charset="utf-8"><\/script>\n<link rel="stylesheet" href="yourpath/dist/he-tree-vue3.css" />\n\x3c!-- usage --\x3e\n<script type="text/javascript">\n  var Tree = heTreeVue3.BaseTree;\n  var Fold = heTreeVue3.Draggable;\n  ...\n<\/script>\n'}),O])])}]]))}}}));
